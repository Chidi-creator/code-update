Flet winCounter = 0;
let loseCounter = 0;
let drawCounter = 0;

function compChoice(param1, param2, param3){

let gameStrings = [param1, param2, param3];
// this line of code below tells the computer to pick randomly out of the parameters in the game strings variable
let randomChoice = Math.floor(Math.random() * gameStrings.length);

let selectedChoice = gameStrings[randomChoice];


return selectedChoice;

 }

 // we equate some parameters to the choices in the in the game so that the computer can pick from them

 let choice1 = "ROCK";
 let choice2 = "PAPER";
 let choice3 = "SCISSORS";

 // We parse the computer choices set in the parameter to the function
 let selectedParameter = compChoice(choice1, choice2, choice3);

 console.log("Computer picks " + selectedParameter);

 
function gameRound() {



if (playerUpper === "ROCK" && selectedParameter === "ROCK"){


console.log("It's a draw")
drawCounter++;

}
else if (playerUpper === "PAPER" && selectedParameter === "PAPER"){


buttonOne.addEventListener('click', function(){


   

if (numberDisplay.textContent == "0" || opBar.textContent ==){

numberDisplay.textContent = "1"

}




else if (numberDisplay.textContent.length == 9){

return;
}

else{

    numberDisplay.textContent += "1";

}

})

clearButton.addEventListener('click', function(){

numberDisplay.textContent = "0"

});


buttonTwo.addEventListener('click', function(){

    if (numberDisplay.textContent == "0"){

        numberDisplay.textContent = "2"
        
        }
        else if (numberDisplay.textContent.length == 9){

            return;
            }
        
        else{
        
            numberDisplay.textContent += "2";
        
        }
        


});


buttonThree.addEventListener('click', function(){

    if (numberDisplay.textContent == "0"){

        numberDisplay.textContent = "3"
        
        }
        else if (numberDisplay.textContent.length == 9){

            return;
            }
        else{
        
            numberDisplay.textContent += "3";
        
        }
        

});

buttonFour.addEventListener('click', function(){

    if (numberDisplay.textContent == "0"){

        numberDisplay.textContent = "4"
        
        }
        else if (numberDisplay.textContent.length == 9){

            return;
            }
        
        else{
        
            numberDisplay.textContent += "4";
        
        }
        

});

buttonFive.addEventListener('click', function(){

    if (numberDisplay.textContent == "0"){

        numberDisplay.textContent = "5"
        
        }
        else if (numberDisplay.textContent.length == 9){

            return;
            }
        
        else{
        
            numberDisplay.textContent += "5";
        
        }

});

    buttonSix.addEventListener('click', function(){

        if (numberDisplay.textContent == "0"){

            numberDisplay.textContent = "6"
            
            }
            else if (numberDisplay.textContent.length == 9){
    
                return;
                }
            
            else{
            
                numberDisplay.textContent += "6";
            
            }

    });

    buttonSeven.addEventListener('click', function(){

        if (numberDisplay.textContent == "0"){

            numberDisplay.textContent = "7"
            
            }
            else if (numberDisplay.textContent.length == 9){
    
                return;
                }
            
            else{
            
                numberDisplay.textContent += "7";
            
            }
    });


        buttonEight.addEventListener('click', function(){

            if (numberDisplay.textContent == "0"){

                numberDisplay.textContent = "8"
                
                }
                else if (numberDisplay.textContent.length == 9){
        
                    return;
                    }
                
                else{
                
                    numberDisplay.textContent += "8";
                
                }
        })


        buttonNine.addEventListener('click', function(){


            if (numberDisplay.textContent == "0"){

                numberDisplay.textContent = "9"
                
                }
                else if (numberDisplay.textContent.length == 9){
        
                    return;
                    }
                
                else{
                
                    numberDisplay.textContent += "9";
                
                }

        });

        buttonZero.addEventListener('click', function(){
            if (numberDisplay.textContent == "0"){

                numberDisplay.textContent = "0"
                
                }
                else if (numberDisplay.textContent.length == 9){
        
                    return;
                    }
                
                else{
                
                    numberDisplay.textContent += "0";
                
                }

        });

    buttonAdd.addEventListener('click', function(){
opBar.textContent = "add";


    })


    console.log("It's a draw");
    drawCounter++;

}

else if (playerUpper === "SCISSORS" && selectedParameter === "SCISSORS") {

console.log("It's a draw");
drawCounter++

}

else if (playerUpper === "ROCK" && selectedParameter === "PAPER")
{
console.log ("You lose! Paper beats rock");
loseCounter++

}
else if (playerUpper === "PAPER" && selectedParameter === "SCISSORS"){


console.log("You lose! Scissors beats paper");
loseCounter++;
}
else if (playerUpper === "SCISSORS" && selectedParameter === "ROCK")
{
console.log("You lose! Rock beats Scissors");
loseCounter++
}
else if (playerUpper === "ROCK" && selectedParameter === "SCISSORS")
{
console.log("You win! Rock beats Scissors");
winCounter++;
}
else if (playerUpper === "PAPER" && selectedParameter === "ROCK")
{
console.log("You win! Paper beats Rock")
winCounter++
}
else if (playerUpper === "SCISSORS" && selectedParameter === "PAPER")
{
console.log("You Win! Scissors beats Paper")
winCounter++
}
else{

    console.log("Wrong Parameters")
}



}







}





gameRound();


}
 
if (loseCounter > winCounter && winCounter > drawCounter){

    console.log("YOU LOSE THIS ROUND!");
}
else if (winCounter > drawCounter && winCounter > loseCounter){

    console.log("YOU WIN THIS ROUND!");
}
else if ( drawCounter > winCounter && drawCounter > loseCounter){
    alert("The draws for this round is more than the wins and losses,refresh the page ");
}


console.log(" Scores for this round: " + "Wins: " + winCounter + " Draws: " + drawCounter + " Losses: " + loseCounter);


    let regex = /[!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~]/g;
    let result = string.replace(regex, "");

let numberDisplay = document.querySelector('.num-display');
let buttonOne = document.querySelector('.one');
let buttonTwo = document.querySelector('.two');
let buttonThree = document.querySelector('.three');
let buttonFour = document.querySelector('.four');
let buttonFive = document.querySelector('.five');
let buttonSix = document.querySelector('.six');
let buttonSeven = document.querySelector('.seven');
let buttonEight = document.querySelector('.eight');
let buttonNine = document.querySelector('.nine');
let clearButton = document.querySelector('.clear');
let buttonZero = document.querySelector('.zero');
let buttonEquals = document.querySelector('.equal-to');
let buttonMultiply = document.querySelector('.multiply');
let buttonAdd = document.querySelector('.add');
let buttonSub = document.querySelector('.sub');
let buttonDivide = document.querySelector('.divide');
let opBar = document.querySelector('.operation-bar');



background: linear-gradient(120deg, #FF00C7 0%, #51003F 100%), linear-gradient(120deg, #0030AD 0%, #00071A 100%), linear-gradient(180deg, #000346 0%, #FF0000 100%), linear-gradient(60deg, #0029FF 0%, #AA0014 100%), radial-gradient(100% 165% at 100% 100%, #FF00A8 0%, #00FF47 100%), radial-gradient(100% 150% at 0% 0%, #FFF500 0%, #51D500 100%);
background-blend-mode: overlay, color-dodge, overlay, overlay, difference, normal;

HIIT project content***
  About
  Services
  Projects
  Contact

  We are creatives

  Transform your brand

  We are a full-service creative agency specializing in helping brands grow fast. 
  Engage your clients through compelling visuals that do most of the marketing for you.

  Learn more

  Stand out to the right audience

  Using a collaborative formula of designers, researchers, photographers, videographers, and copywriters, we’ll build and extend your brand in digital places. 

  Learn more

  Graphic design
  Great design makes you memorable. We deliver artwork that underscores your brand message and captures potential clients’ attention.

  Photography
  Increase your credibility by getting the most stunning, high-quality photos that improve your business image.

  Client testimonials

  We put our trust in Sunnyside and they delivered, making sure our needs were met and deadlines were always hit.
  Emily R.
  Marketing Director

  Sunnyside’s enthusiasm coupled with their keen interest in our brand’s success made it a satisfying and enjoyable experience.
  Thomas S.
  Chief Operating Officer

  Incredible end result! Our sales increased over 400% when we worked with Sunnyside. Highly recommended!
  Jennie F.
  Business Owner

  About
  Services
  Projects
  Contact

  <div class="attribution">
    Challenge by <a href="https://www.frontendmentor.io?ref=challenge" target="_blank">Frontend Mentor</a>. 
    Coded by <a href="#">Your Name Here</a>.
  </div>


quired>

      <label for="email">Email:</label>
      <input type="email" id="email" name="email" required>

      <button type="submit">Submit</button>
    </form>
  </div>
</div>
</body>

const openModalBtn = document.getElementById("openModalBtn");
openModalBtn.addEventListener("click", function() {
  const modal = document.getElementById("modal");
  modal.style.display = "block";
});

// Close the modal when the close button is clicked
const closeButton = document.getElementsByClassName("close")[0];
closeButton.addEventListener("click", function() {
  const modal = document.getElementById("modal");
  modal.style.display = "none";
});

// Handle form submission
const form = document.getElementById("myForm");
form.addEventListener("submit", function(event) {
  event.preventDefault(); // Prevent the form from submitting

  // Get the form values
  const name = document.getElementById("name").value;
  const email = document.getElementById("email").value;

  // Use the form values as needed
  console.log("Name:", name);
  console.log("Email:", email);

  // Clear the form inputs
  form.reset();

  // Close the modal
  const modal = document.getElementById("modal");
  modal.style.display = "none";
});

.modal {
    display: none;
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
  }
  
  .modal-content {
    background-color: #fefefe;
    margin: 10% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 300px;
  }
  .close {
    float: right;
    cursor: pointer;
  }
  
  .close:hover {
    color: red;
  }

let myLibrary = [];


hnvgfgf


const colors = ["#67e8f9", "#fecaca", "#facc15", "#6366f1", "#fae8ff"]


boxes.forEach(function (box) {
  box.addEventListener("click", function () {
    if (currentTurn == 1 && box.textContent == "") {
      box.textContent = player1.marker;
      currentTurn = 2;
    } else if (currentTurn == 2 && box.textContent == "") {
      box.textContent = player2.marker;
      currentTurn = 1;
    } else {
      alert("Enter into an empty box");
    }
  });
});

  function Players (name, marker) {
    this.name = name;
    this.marker = marker;

  }

  const playerX = new Players (playerOneName.value, 'X')
  const playerO = new Players (playerOneName.value, 'O')
  




let displayButton = 1;

 submitBtn.addEventListener("click", function () {
  displayButton = 2;
  submitted = 2;
  const playerOneInput = playerOneName.value;
  const playerTwoInput = playerTwoName.value;
  draw.style.display = "flex";
  const gapValue = "10px";
  drawDisplay.textContent = drawCounter;
  draw.style.gap = gapValue;

  winnerOne.textContent =
    playerOneName.value.toUpperCase() + " : " + oneCounter;
  winnerTwo.textContent =
    playerTwoName.value.toUpperCase() + " : " + twoCounter;
  if (playerOneInput !== "" && playerTwoInput !== "") {
    openFirstPlayer();
    pName.textContent = playerOneInput.toUpperCase() + " STARTS AS X!!";
  } else {
    openFirstPlayer();
    pName.textContent = "PLEASE FILL THE NAME BARS!!!";
  }
});


function roundCheck(){
if (displayButton === 2){
  playAgain.style.display = "none"
}
else if (oneCounter === 3){
    pName.textContent = playerOneName.value.toUpperCase() + " WINS THIS ROUND"
    playAgain.style.display = "block"

  }
  else if (twoCounter === 3){
    pName.textContent = playerTwoName.value.toUpperCase() + " WINS THIS ROUND "
    playAgain.style.display = "block"
  }
  else if ( drawCounter === 3){
    pName.textContent = "THIS ROUND ENDS AS A DRAW"
    playAgain.style.display = "block"
    
  }
}
reset.addEventListener("click", function () {
  displayButton = 1;
  closeModal();
  clearName();
  clearBoxes();
  winnerOne.textContent = "";
  winnerTwo.textContent = "";
  draw.style.display = "none";
  submitted = 1;

});

const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, 'dist'),
  },
}

function addToProjectDivs() {
  const newProjectDiv = document.createElement("div");
  const projectImage = document.createElement("img");
  projectImage.src = "images/list-box.svg";
  const newProjectText = document.createElement("div");
  newProjectText.style.display = "flex";
  const projectImageTwo = document.createElement("img");
  projectImageTwo.src = "images/delete.svg";
  projectImageTwo.classList.add("img-filter");
  newProjectDiv.classList.add("add2");
  newProjectText.textContent = projectInput.value;

  if (newProjectText.textContent != "") {
    newProjectDiv.appendChild(projectImage);
    newProjectDiv.appendChild(newProjectText);
    newProjectDiv.appendChild(projectImageTwo);
    projectContent.appendChild(newProjectDiv);

    localStorage.setItem("projectContent", projectContent.innerHTML);
  } else {
    alert("Enter Project");
  }
  projectImageTwo.addEventListener("click", function () {
    projectContent.removeChild(newProjectDiv);
  });
}

document.addEventListener("DOMContentLoaded", function () {
  if (localStorage.getItem("projectContent")) {
    const storedProjectContent = localStorage.getItem("projectContent");
    projectContent.innerHTML = storedProjectContent;

    // Attach event listeners to the delete buttons
    const deleteButtons = projectContent.querySelectorAll(".img-filter");
    deleteButtons.forEach(function (button) {
      button.addEventListener("click", function () {
        const divToRemove = button.parentNode;
        projectContent.removeChild(divToRemove);
        // Update the stored projectContent HTML in localStorage after removing the element
        setTimeout(function () {
          localStorage.setItem("projectContent", projectContent.innerHTML);
        },0);
      });
    });

    const readd = projectContent.querySelector(".add");
    readd.addEventListener("click", function () {
      openProjectModal(projectModal);
    });
  }
});

function addToTodaysDivs() {
  const newTodayDivs = document.createElement("div");
  const todayImage = document.createElement("img");
  todayImage.src = "images/format-list-bulleted.svg";
  const newTodayText = document.createElement("div");
  newTodayText.style.display = "flex";
  const todayImageTwo = document.createElement("img");
  todayImageTwo.src = "images/delete.svg";
  todayImageTwo.classList.add("img-filter");
  newTodayDivs.classList.add("add3");
  newTodayText.textContent = todayInput.value;


  if (newTodayText.textContent != "") {
    newTodayDivs.appendChild(todayImage);
    newTodayDivs.appendChild(newTodayText);
    newTodayDivs.appendChild(todayImageTwo);
    todayDivs.appendChild(newTodayDivs);

    localStorage.setItem("todayDivs", todayDivs.innerHTML);
  } else {
    alert("Enter today's Task");
  }
  const deleteButtons = todayDivs.querySelectorAll(".img-filter");
  deleteButtons.forEach(function (button) {
    button.addEventListener("click", function () {
      const divToRemove = button.parentNode;
      todayDivs.removeChild(divToRemove);
      // Update the stored todayDivs HTML in localStorage after removing the element
      localStorage.setItem("todayDivs", todayDivs.innerHTML);
    });
  });

}

document.addEventListener("DOMContentLoaded", function () {
  if (localStorage.getItem("projectContent")) {
    const storedProjectContent = localStorage.getItem("projectContent");
    projectContent.innerHTML = storedProjectContent;

    // Attach event listeners to the delete buttons
    const deleteButtons = projectContent.querySelectorAll(".img-filter");
    deleteButtons.forEach(function (button) {
      button.addEventListener("click", function () {
        const divToRemove = button.parentNode;
        projectContent.removeChild(divToRemove);
        // Update the stored projectContent HTML in localStorage after removing the element
        localStorage.setItem("projectContent", projectContent.innerHTML);
      });
    });

    const readd = projectContent.querySelector(".add");
    readd.addEventListener("click", function () {
      openProjectModal(projectModal);
    });
  }

  if (localStorage.getItem("todayDivs")) {
    const storedTodayContents = localStorage.getItem("todayDivs");
    todayDivs.innerHTML = storedTodayContents;

    // Attach event listeners to the delete buttons
    const deleteButtons = todayDivs.querySelectorAll(".img-filter");
    deleteButtons.forEach(function (button) {
      button.addEventListener("click", function () {
        const divToRemove = button.parentNode;
        todayDivs.removeChild(divToRemove);
        // Update the stored todayDivs HTML in localStorage after removing the element
        localStorage.setItem("todayDivs", todayDivs.innerHTML);
      });
    });
  }
});
  <div class="today-page">
          <div class="the-today">
            <span class="today-heading"><h1>Today</h1></span>
            <div class="today-add">
              <img src="images/plus.svg" alt="" class="today-image-add" />
              <div>Add Tasks</div>
            </div>
            <div class="contents-today"></div>
          </div> 

  function projectPage(){
    const projectPage = document.createElement('div')
    const theToday = document.createElement('div')
    theToday.classList.add('the-project')
    const projectHeading = document.createElement('span')
    const headingText = document.createElement('h1')
    headingText.textContent = 
    projectHeading.appendChild(headingText)
  }
	
const newDivs = document.querySelectorAll(".project-text");
    newDivs.forEach((button) => {
      let buttonText = button.textContent;
      button.addEventListener("click", () => {
        alert(buttonText);
      });
    });

.cover img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    overflow: hidden;
}
#container img{width:100%;}
#container{width:250px; height:250px; overflow:hidden; border:1px solid #000;} 


'http://api.weatherapi.com/v1/current.json?key=3a4fa662aa3046fdaa284241231206&q=London&aqi=yes'


// fetch('http://api.weatherapi.com/v1/current.json?key=3a4fa662aa3046fdaa284241231206&q=London&aqi=yes')
//     .then(res =>{
//         if(!res.ok){
//             console.log('problem')
//         }
//         return  res.json()
//     })
//     .then(data =>{
//         console.log(data)
//         pEl.innerHTML = data.current.condition.text
//     })
//     .catch(error =>{
//         console.log(error)
//     })


const imgEl = document.querySelector("img");
const textInput = document.querySelector(".textinput");
const updateBtn = document.querySelector(".update");
const para = document.querySelector("p");
const trr = textInput.value;


const updateImage = async () => {
  try {
    const trr = textInput.value;

    const res = await fetch(
      "https://api.giphy.com/v1/gifs/translate?api_key=3vuyemKx2t5zKctx7begsvSdNlob0lcj&s=" +
        trr +
        "&weirdness=4"
    );
    const data = await res.json();

    if (!res.ok) {
      console.log("problem");
      return;
    }
    console.log(data);
    imgEl.src = data.data.images.original.url;
  } catch (error) {
    console.log(error);
    para.innerHTML = error;
  }
};

updateImage();

updateBtn.addEventListener("click", () => {
  location.reload();
  updateImage;
});

/* Button styling */
.submit-button {
    display: inline-block;
    padding: 12px 24px;
    font-size: 16px;
    font-weight: bold;
    color: #fff;
    background-color: #007bff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }

  /* Button hover effect */
  .submit-button:hover {
    background-color: #0056b3;
  }

  /* Button animation */
  .submit-button.loading {
    pointer-events: none; /* Disable clicking during animation */
  }

what is the best way to apply edit buttons to object items in an array in order to edit the elements of that array for example my credentials array

  .submit-button.loading::after {
    content: '';
    display: inline-block;
    width: 16px;
    height: 16px;
    margin-left: 8px;
    border: 4px solid #fff;
    border-top-color: transparent;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

This is a simple weather application that displays the current weather information for a specified location. Users can enter a city name in the input field, and the app will fetch and display the weather details using the WeatherAPI.

Features
Displays the location name, temperature, weather description, humidity, wind speed, and current time.
Allows users to enter a city name to get the weather information for that location.
Shows an error modal if there are any issues with fetching the weather data.
Technologies Used
HTML
CSS
JavaScript
Usage
Clone the repository or download the source code.
Open the index.html file in a web browser.
Enter the name of a city in the input field.
Click the "Submit" button to fetch and display the weather information for the specified city.
The weather details will be shown in the app, including the temperature, weather description, humidity, wind speed, and current time.
If there are any errors in fetching the weather data, an error message will be displayed in a modal.
Credits
WeatherAPI - Used to fetch weather data.
License
This project is licensed under the MIT License.


const MyButton = () =>{
  return (
    <button>I am a button</button>
  );
}

export default function MyApp() {
  return (
    <div>
      <h1>Wellcome to My app</h1>
      <MyButton />
    </div>
  )
}

git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/Chidi-creator/git-testing.git
git push -u origin main



const [count, setCount] = useState(null)

    const clickHandler = () =>{
      setCount(count + 1)
      console.log(count)

<button onClick={clickHandler}>Clicked Me {count} times</button>

import React, { useState } from "react";

const ItemList = () => {
  const [items, setItems] = useState([]); // State variable to store the list of items
  const [inputValue, setInputValue] = useState(""); // State variable to store the input value

  const handleInputChange = (event) => {
    setInputValue(event.target.value); // Update the input value state variable
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    setItems([...items, inputValue]); // Add the input value to the items array
    setInputValue(""); // Clear the input value
  };

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input
          type="text"
          value={inputValue}
          onChange={handleInputChange}
        />
        <button type="submit">Add Item</button>
      </form>

      <ul>
        {items.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
};

export default ItemList;


setItems(items.concat(inputValue));  is the same as setItems([...items, inputvalue]);

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Imperdiet massa tincidunt nunc pulvinar sapien et ligula. Tincidunt nunc pulvinar sapien et ligula. Ut ornare lectus sit amet est placerat. A cras semper auctor neque. Molestie at elementum eu facilisis sed odio morbi quis commodo. Metus vulputate eu scelerisque felis imperdiet proin. Platea dictumst quisque sagittis purus sit amet volutpat consequat mauris. Diam phasellus vestibulum lorem sed risus. Massa tempor nec feugiat nisl pretium fusce. Nec feugiat nisl pretium fusce. Consectetur adipiscing elit ut aliquam. Molestie at elementum eu facilisis sed odio. Facilisi nullam vehicula ipsum a arcu cursus vitae. Duis at consectetur lorem donec. Mauris in aliquam sem fringilla ut morbi.

Est velit egestas dui id ornare arcu odio. Ut porttitor leo a diam sollicitudin tempor. Ipsum nunc aliquet bibendum enim. Nisl nisi scelerisque eu ultrices vitae auctor eu. Vitae et leo duis ut diam quam nulla porttitor massa. Nulla pharetra diam sit amet nisl suscipit. Diam maecenas ultricies mi eget mauris pharetra et. Et tortor at risus viverra adipiscing at in tellus integer.

 
padding: 20px;
  display: flex;
  align-items: center;
  max-width: 600px;
  margin: 0 auto;
  border-bottom: 1px solid #f2f2f2;
}
.the-contaier{
display:flex;
flex-wrap:wrap;
justify-content: space-between;
max-width: 760px;
margin: 30px auto
}
divs wrapping the form control{
width:calc(50%-10px)
}

.general{
  display:flex;
  justify-content: space-between;
  max-width: 700px;
  flex-wrap: wrap;
  margin: 30px auto;
 margin-left: 70px;
}



.general > div {
  width: calc(50% - 10px); /* Adjust the width based on your spacing needs */
  margin-bottom: 20px; /* Add margin-bottom for vertical spacing between form divs */
}

// Edit functioality jsx

const handleEdit = (editedCredential) => {
    setCredentials((prevCredentials) =>
      prevCredentials.map((credential) =>{
      if (credential.id === editedCredential.id) {
        return editedCredential;
      } else {
        return credential;
      }
    }
      )
    );
  };
import { useParams, Link } from "react-router-dom";
import { useState, useEffect } from "react";

const EditCredential = ({ credentials, handleEdit }) => {
  const { id } = useParams();

  const [editedCredential, setEditedCredential] = useState({});

  useEffect(() => {
    const credential = credentials.find((credential) => credential.id === parseInt(id));
    setEditedCredential(credential);
  }, [id, credentials]);

  const handleChange = (e) => {
    setEditedCredential({
      ...editedCredential,
      [e.target.name]: e.target.value,
    });
  };

  const handleSaveEdit = () => {
    handleEdit(editedCredential);
  };

  return (
    <div>
      <h2>Edit Credential</h2>
      <input
        type="text"
        name="firstName"
        value={editedCredential.firstName}
        onChange={handleChange}
      />
      <input
        type="text"
        name="lastName"
        value={editedCredential.lastName }
        onChange={handleChange}
      />
      {/* Render other editable fields */}
      <button onClick={handleSaveEdit}>Save</button>
      <Link to="/credentialPreview">Back to Credential Preview</Link>
    </div>
  );
};

export default EditCredential;


 course,
      grad,
      grade,
      former,
      time,
      role,
      merits,

University Attended:
Course of Study:
Date of graduation:
CGPA:
Experience
Former Company:
Time Spent in company:
Position Applied For:
Merits or award:

  useEffect(() => {
    const storedTasks = localStorage.getItem('tasks');
    if (storedTasks) {
      setTasks(JSON.parse(storedTasks));
    }
  }, []);

  // Save tasks to local storage whenever it changes
  useEffect(() => {
    localStorage.setItem('tasks', JSON.stringify(tasks));
  }, [tasks]);

.general {
  display: flex;
  justify-content: space-between;
  max-width: 700px;
  flex-wrap: wrap;
  /* margin: 30px auto; */
  padding: 50px;
  background-color: whitesmoke;
 
}
.title {
  position: absolute;
  transform: translate(180px, -69px);
}

.general > div {
  width: calc(50% - 50px); /* Adjust the width based on your spacing needs */
  margin-bottom: 20px; /* Add margin-bottom for vertical spacing between form divs */

}
.education {
  display: flex;
  justify-content: space-between;
  max-width: 700px;
  flex-wrap: wrap;
  /* margin: 30px auto; */
  padding: 50px;
  background-color: whitesmoke;
  
}

.education > div {
  width: calc(50% - 50px); /* Adjust the width based on your spacing needs */
  margin-bottom: 20px; /* Add margin-bottom for vertical spacing between form divs */
}
.experience {
  display: flex;
  justify-content: space-between;
  max-width: 700px;
  flex-wrap: wrap;
  /* margin: 30px auto; */
  padding: 50px;
  background-color: whitesmoke;

}

.experience > div {
  width: calc(50% - 50px); /* Adjust the width based on your spacing needs */
  margin-bottom: 20px; /* Add margin-bottom for vertical spacing between form divs */
}

input {
  margin-top: 10px;
  width: 200px;
}
.submit-button {
  display: inline-block;
  padding: 12px 24px;
  font-size: 16px;
  font-weight: bold;
  color: #fff;
  background-color: #4CAF50;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s ease;
  transform: translate(300px);
  margin-top: 10px;
}

/* Button hover effect */
.submit-button:hover {
  background-color: #0056b3;
}

/* Button animation */
.submit-button.loading {
  pointer-events: none; /* Disable clicking during animation */
}

npm create vite@latest my-first-react-app -- --template react






// typescript
npm create vite@latest my-first-react-app -- --template react-ts


  {picks.map((pick) => {
        return (
          <>
          
          {
            picks && (
              <div className="picked" key={pick.character.mal_id}>
              <p>{pick.character.name}</p>
            </div>
            )
          }
          </>
        );
      })}

  if (picks && picks.length > 0 && picks[0].character) {
      console.log(picks[0].character);
    }

// json server
npx json=server --watch filepath.json --port 6677

        // img.id === image.id ? { ...image, alreadyClicked: true } : img

// font awesome
npm install --save @fortawesome/fontawesome-svg-core @fortawesome/free-solid-svg-icons @fortawesome/react-fontawesome

//install react-router-dom
npm install react-router-dom @6
import { BrowserRouter as Router, Route, Routes } from "react-router-dom";
// react-router version 6

import { BrowserRouter as Router, Route, Routes } from "react-router-dom";
<Router>
<Routes>
<Route path = '#' element ={<Component />}
</Routes>
</Router>

//div with image inside 

.contents {
  max-width: 600px;
  margin: 0 auto;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
  gap: 10px;
}
.pic {
  height: 200px;
  width: 200px;
}
.pic img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  overflow: hidden;
}

rendering conditional components css//
{
position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
}

.cart-container{
  max-width: 600px;
  margin: 40px auto;
  padding: 20px;
}
.cart-item{
  padding: 10px 16px;
  margin: 20px 0;
  border-bottom: 1px solid #fafafa;
}
.cart-item :hover{
  box-shadow: 1px 3px 5px rgba(0,0,0,0.1);
}

/* Styling for the modal overlay */
.modal-overlay {
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
}

/* Styling for the modal content */
.modal-content {
  display: flex;
  flex-direction: column;
  gap: px;
  align-items: center;
  background-color: #fefefe;
  padding: 10px;
  border-radius: 8px;
  box-shadow: 0px 2px 8px rgba(0, 0, 0, 0.2);
}

{/* <div className={`menu-nav ${isOpen ? "show-options" : ""}`}>
            <span className="nav-options">Electronics</span>
            <span className="nav-options">Jewelry</span>
            <span className="nav-options">Mens Clothing</span>
            <span className="nav-options"> Women's Clothing</span> */}

  <span className="nav-options">Electronics</span>
            <span className="nav-options">Jewelry</span>
            <span className="nav-options">Mens Clothing</span>
  <span className="nav-options"> Women's Clothing</span>

import React, { useRef } from "react";

function App() {
  const fRef = useRef(null);

  const handleClick = (ev) => {
    const f = fRef.current;
    if (f) {
      f.style.transform = `translateY(${ev.clientY - 25}px) translateX(${ev.clientX - 25}px)`;
    }
  };

  return (
    <div>
      <div id="foo" ref={fRef}>
        Click Me!
      </div>
      <button onClick={handleClick}>Move</button>
    </div>
  );
}

export default App;


// tailwind restart react
npx tailwindcss -i ./src/index.css -o ./dist/output.css --watch

// tailwind restart html
npx tailwindcss -i style.css -o ./dist/output.css --watch

npx tailwindcss init --full

, { useNewUrlParser: true, useUnifiedTopology: true }

//POST request
const handleSubmit = async (e) => {
        e.preventDefault();
      
 
        const workout = { title, load, reps }- the useState vars
      
        const res = await fetch('http://localhost:4000/chidi/workouts', {
          method: 'POST',
          body: JSON.stringify(workout),
          headers: {
            'Content-Type': 'application/json',
          },
        });
        const json = await res.json();
      
        if (!res.ok) {
          setError(json.error);
        }
        if (res.ok) {
          setTitle('');
          setReps('');
          setLoad('');
          setError(null);
          console.log('new workout added', json);
        }
      };

// using useReducer to connect db and UI

/* eslint-disable react/prop-types */
import { createContext, useReducer } from "react";

export const WorkoutContext = createContext()

 const workoutsReducer = (state, action) =>{
    switch(action.type){
        case 'SET_WORKOUTS':
            return {
                workouts: action.payload
            }
            case 'CREATE_WORKOUT':
                return {
                    workouts: [action.payload, ...state.workouts]
                }
                default:
                    return state
    }

}




  export const WorkoutContextProvider = ({children}) =>{
    const [state, dispatch] = useReducer(workoutsReducer, {
        workouts: null
    })
    
    return (
        <WorkoutContext.Provider value={{...state, dispatch}}>
            {children}
        </WorkoutContext.Provider>
    )
}

//custom hook
import {WorkoutContext} from '../context/WorkoutContext'
import { useContext } from 'react'

export const useContextHook = () =>{
    const context = useContext(WorkoutContext)

    if(!context){
        throw Error("Wrong context scope")
    }

    return context
}

// react context hook cheat sheet

Define a Context:

Create a context file that includes the state and a function to update the state.
jsx

// DataContext.js
import React, { createContext, useState } from 'react';

const DataContext = createContext();

const DataProvider = ({ children }) => {
  const [data, setData] = useState([]);

  const addDataItem = (newItem) => {
    setData((prevData) => [...prevData, newItem]);
  };

  return (
    <DataContext.Provider value={{ data, addDataItem }}>
      {children}
    </DataContext.Provider>
  );
};

export { DataContext, DataProvider };
Wrap Your App with the Provider:

Wrap your main App component with the DataProvider to make the context available throughout your app.
jsx

// App.js
import React from 'react';
import { DataProvider } from './DataContext';
import ComponentA from './ComponentA';

const App = () => {
  return (
    <DataProvider>
      <ComponentA />
    </DataProvider>
  );
};

export default App;
Access Context in Another Component:

In the component where you want to add to the array, use the useContext hook to access the context and the addDataItem function.
jsx
Copy code
// ComponentB.js
import React, { useContext } from 'react';
import { DataContext } from './DataContext';

const ComponentB = () => {
  const { addDataItem } = useContext(DataContext);

  const handleAddItem = () => {
    const newItem = // your new data item;
    addDataItem(newItem);
  };

  return (
    <div>
      <button onClick={handleAddItem}>Add Item</button>
    </div>
  );
};

export default ComponentB;
Now, when you click the "Add Item" button in ComponentB, it will call the addDataItem function from the context, and the new item will be added to the array in the state in ComponentA. Adjust the code according to your specific use case.



//usesignup hook
import { useState } from "react";
import { useAuthContext } from "./useAuthContext";


const useSignup = () => {
    const [error, setError] = useState(null)
    const [isLoading, setIsLoading] = useState(null)
    const {dispatch} = useAuthContext

    const signup = async (email, password) =>{
        setIsLoading(true)
        setError(null)

        const res =  await fetch('http://localhost:4000/chidi/user/signup/', {
            method: 'POST', 
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({email, password})
        })
        const json = await res.json()

        if(!res.ok){
            setIsLoading(false)
            setError(json.error)
        }
        if(res.ok){
            // save the user to local storage
            localStorage.setItem('user', JSON.stringify(json))

            //update authcontext
            dispatch({type: 'LOGIN', payload: json})

            setIsLoading(false)

        }
    }
    return {signup, error, isLoading}
}


// installing nodemon
npm install --save-dev nodemon

 
export default useSignup;

// login hook
login is almost similar to signup hook. Not much difference

//require auth middleware
const jwt = require('jsonwebtoken')
const User = require('../model/userModel')

const requireAuth = async (req, res, next) =>{


    //verify authentication
    const { authorization } = req.headers

    if(!authorization){
        return res.status(401).json({error: 'Authorization token required'})
    }

    const token = authorization.split(' ')[1]

    try{
    const {_id} =  jwt.verify(token, process.env.SECRET)

    req.user = await User.findOne({ _id }).select('_id')
    next()
    
    }catch(error){
        res.status(401).json({error: 'Request is not authorised'})
    }
}

module.exports = requireAuth
'
//format for context api
/* eslint-disable react/prop-types */
import { createContext,useEffect,  useReducer } from "react";

export const AuthContext = createContext()

 const authReducer = (state, action) =>{
    switch (action.type) {
        case 'LOGIN' :
            return {user : action.payload}

            case 'LOGOUT':
                return {user: null}
                default: 
                return state
    }
}


const AuthContextProvider = ({children}) => {
    const [state, dispatch] = useReducer(authReducer, {
        user: null
    })
    useEffect(() =>{
        const user = JSON.parse(localStorage.getItem('user'))

        if(user){
            dispatch({type: 'LOGIN', payload: user})
        }
    
    }, [])
    

    
    console.log('AuthContext state' , state)

    return (
        <AuthContext.Provider value={{...state, dispatch}}>
            {children}
        </AuthContext.Provider>
    )
}
 
export default AuthContextProvider;

then you wrap your main.jsx
  <AuthContextProvider>
    <WorkoutContextProvider>
    <App />
    </WorkoutContextProvider>
    </AuthContextProvider>

//then create a custom hook to be able to use it anywhere
	import {AuthContext} from '../context/AuthContext'
import { useContext } from 'react'

export const useAuthContext = () =>{
    const context = useContext(AuthContext)

    if(!context){
        throw Error("Wrong context scope")
    }

    return context
}


then applying it:
import { useAuthContext } from "./useAuthContext";
const {dispatch} = useAuthContext()

			OR:
import { useAuthContext } from "../hooks/useAuthContext";
const { user } = useAuthContext()

express security error:
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser

//connect to db
mongoose.connect(process.env.MONGO_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
.then(() =>{

//listen for requests
app.listen(process.env.PORT, () =>{
    console.log(`connected to db and listening on port ${process.env.PORT}`)
})
})
.catch(err =>{
    console.log(err)
})
//connecting to db method 2
mongoose.connect(process.env.MONGO_URI)
.then(() =>{
    //listen for requests
    app.listen(process.env.PORT, () =>{
        console.log(`connected to db and running on port ${[process.env.PORT]}`)
    })    
})
.catch(err =>{
    console.log(err)
})
"mongodb+srv://tyler_igwe:CHinyere12*@cluster0.es3xjb8.mongodb.net/local_library?retryWrites=true&w=majority"

Local Library represents name of db.

//checking for id validity
if(!mongoose.Types.ObjectId.isValid(id)){
        return res.status(404).json({error: "No such id"})

    }

node is not a programming languagage it's a runtime

events in node:
exit
calling it

process.on('exit', () =>{


})

the module for reading file is ('fs)

//working with view engines 'ejs'
sending ejs files back you use app.render("index") 
sending data back to the html fileapp.render("index", {text: "whatever"}) 


//basic model Schema
const mongoose  = require('mongoose')

const Schema = mongoose.Schema

const employeeSchema = new Schema({
    firstname:{
        type: String,
        required: true
    },
    lastname: {
        type: String,
        required: true
    }
})

module.exports = mongoose.model('Employee', employeeSchema)


// common post request:

router.post('/', async (req, res) =>{
    const {name,  subscribedToChannel} = req.body

    try{
        const newSubscriber = await Subscriber.create({name, subscribedToChannel})
        res.status(201).json({ message: "Subscriber created successfully", subscriber: newSubscriber });
    }catch(err){
        res.status(500).json({message: err.message})
    }
})


// code to get id for any kini

const getSubscriber = async (req, res, next) => {
    const { id } = req.params;
    try {
      const subscriber = await Subscriber.findById(id);
      if (!subscriber) {
        return res.status(404).json({ message: "Cannot find subscriber" });
      }
      res.subscriber = subscriber;
      next();
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  };

// for patching or updating user and stuff
router.patch("/:id", getSubscriber, async (req, res) => {
  

  if (req.body.name !=null){
    res.subscriber.name = req.body.name
  }
  if (req.body.subscribedToChannel != null){
    res.subscriber.subscribedToChannel = req.body.subscribedToChannel
  }
  try{
    
    const updatedSubscriber = await res.subscriber.save()
    res.json(updatedSubscriber)

  }catch(err){
            res.status(400).json({message: err.message})
  }


});


//exit on uncaught errors
process.on('uncaughtException', err =>{
    console.error(`There was an uncaught error: ${err} `)
    process.exit(1)
})



 const accessToken = jwt.sign(
      { username: foundUser.username },
      process.env.ACCESS_TOKEN_SECRET,
      { expiresIn: "30s" }
    );
    const refreshToken = jwt.sign(
      { username: foundUser.username },
      process.env.REFRESH_TOKEN_SECRET,
      { expiresIn: "1d" }
    );

const verifyJWT = (req, res, next) =>{
    const {authorization} = req.headers
    if(!authorization) return res.sendStatus(401)
        console.log(authorization)
    const token = authorization.split(' ')[1]
    jwt.verify(
        token,
        process.env.ACCESS_TOKEN_SECRET,
        (err, decoded) =>{
            if (err) return res.sendStatus(403)
                req.user = decoded.username
            next()
        }
    )
}

const verifyJWT = (req, res, next) =>{
    // extracting data from the token
    const {authorization} = req.headers
    if(!authorization) return res.sendStatus(401)
        console.log(authorization)
    const token = authorization.split(' ')[1]
    jwt.verify(
        token,
        process.env.ACCESS_TOKEN_SECRET,
        (err, decoded) =>{
            if (err) return res.sendStatus(403)
                req.user = decoded.username
            next()
        }
    )
}


//handle refreshtoken

const handleRefreshToken = async (req, res) => {
  const cookies = req.cookies;
  if (!cookies?.jwt) return res.sendStatus(401);
  console.log(cookies.jwt);
  const refreshToken = cookies.jwt;

  const foundUser = userDB.users.find(
    (person) => person.refreshToken === refreshToken
  );
  if (!foundUser) return res.sendStatus(403);
  //evaluate jwt
  jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET, (err, decoded) => {
    if (err || foundUser.username !== decoded.username)
      return res.sendStatus(403);
    const accessToken = jwt.sign(
      {
        username: decoded.username,
      },
      process.env.ACCESS_TOKEN_SECRET,
      { expiresIn: "30s" }
    );
    res.json({accessToken})
  });
};

const handleLogOut = async (req, res) => {
  //on client, also delete the access token

  const cookies = req.cookies;
  if (!cookies?.jwt) return res.sendStatus(204);

  const refreshToken = cookies.jwt;

  //is refresh token in db

  const foundUser = userDB.users.find(
    (person) => person.refreshToken === refreshToken
  );
  if (!foundUser) {
    res.clearCookie("jwt", { httpOnly: true });
    return res.sendStatus(204);
  }
  //Delete refreshToken in db
  const otherUsers = userDB.users.filter(
    (person) => person.refreshToken != refreshToken
  );
  const currentUser = { ...foundUser, refreshToken: "" };

  userDB.setUsers([...otherUsers, currentUser]);
  await fsPromises.writeFile(
    path.join(__dirname, "..", "model", "users.json"),
    JSON.stringify(userDB.users)
  );
  res.clearCookie("jwt", refreshToken, {
    httpOnly: true, sameSite: 'None', secure: true
 
  });
  res.sendStatus(204);
};

//higher order function, roles P
const verifyRoles = (...allowedRoles) => {
  return (req, res, next) => {
    if (!req?.roles) return res.sendStatus(401);
    const rolesArray = [...allowedRoles];
    console.log(rolesArray);
    console.log(req.roles);
    const result = req.roles
      .map((role) => rolesArray.includes(role))
      .find((val) => val === true);
    if (!result) return res.sendStatus();
    next();
  };
};

module.exports = {verifyRoles}

//check what happens when it connect once
mongoose.connection.once('open', () =>{
  app.listen(PORT, () => {
    console.log(`server is connected to DB and running on ${PORT}`);
  });

const mongoose = require('mongoose')

const connectDB = async () =>{
    try{

        await mongoose.connect(process.env.DATABASE_URI)

    }catch(err){
        console.log(err)
    }
}

module.exports = {connectDB}

standard for naming models is starting them with capital letter  

//short hand for type: number
Editor: Number,
        Admin: Number,


//to findone in the db
  const duplicate = await User.findOne({username: user}).exec()

//editing and saving changes in mongoDB
 const foundUser =  await User.findOne({refreshToken}).exec()
  if (!foundUser) {
    res.clearCookie("jwt", { httpOnly: true });
    return res.sendStatus(204);
  }
  //Delete refreshToken in db
 foundUser.refreshToken = ''

 const result = await foundUser.save()

function to check validity of id//
const mongoose = require('mongoose');

const checkId = (id) => {
  return mongoose.Types.ObjectId.isValid(id);
};

module.exports = { checkId };

using it: if (!checkId(id)) return your error


// Define the Course schema
const courseSchema = new Schema({
  coursename: { type: String, required: true },
  thumbnail: { type: String, required: true },
  genre: { type: String, required: true }  // Typically lowercase field names are preferred
});

// Define the EnrolledCourse schema
const enrolledCourseSchema = new Schema({
  courseId: { type: mongoose.Schema.Types.ObjectId, ref: 'Course', required: true },
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true }
});

// Create models from the schemas
const Course = mongoose.model('Course', courseSchema);
const EnrolledCourse = mongoose.model('EnrolledCourse', enrolledCourseSchema);

//populating based on the ref 
const EnrolledCourse = require('../models/EnrolledCourse');
const Course = require('../models/Course');
const User = require('../models/User');

const enrollInCourse = async (req, res) => {
  const { courseId } = req.params;
  const { userId } = req.body;

  try {
    // Check if the course exists
    const course = await Course.findById(courseId);
    if (!course) return res.status(404).json({ message: 'Course not found' });

    // Check if the user exists
    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ message: 'User not found' });

    // Create a new enrollment
    const newEnrollment = new EnrolledCourse({ courseId, userId });
    await newEnrollment.save();

    res.status(201).json(newEnrollment);
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Server error' });
  }
};

const getEnrolledCourses = async (req, res) => {
  const { userId } = req.params;

  try {
    const enrolledCourses = await EnrolledCourse.find({ userId })
      .populate('courseId')  // Populate with Course details
      .populate('userId');   // Populate with User details

    res.status(200).json(enrolledCourses);
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Server error' });
  }
};

module.exports = { enrollInCourse, getEnrolledCourses };

const mongoose = require('mongoose');
const EnrolledCourse = require('./models/EnrolledCourse'); // Adjust the path as necessary
const Course = require('./models/Course'); // Adjust the path as necessary

const getEnrolledCourses = async (req, res) => {
  const { userId } = req.params;

  try {
    const enrolledCourses = await EnrolledCourse.find({ userId })
      .populate({
        path: 'courseId',
        select: 'coursename thumbnail' // Select only the coursename and thumbnail fields
      });

    // If you want to return only the course details without the rest of the enrolledCourses structure
    const courses = enrolledCourses.map(ec => ({
      coursename: ec.courseId.coursename,
      thumbnail: ec.courseId.thumbnail
    }));

    res.status(200).json(courses);
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Server error' });
  }
};

module.exports = { getEnrolledCourses };







//mapping as objects

  const check = data.map(cr => ({
  coursename:  cr.courseId.coursename,
  thumbnail: cr.courseId.thumbnail

}))

regex for password: 
^(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9]).{8,}$

const USER_REGEX = /^[a-zA-Z][a-zA-Z0-9-_]{3,23}$/;

const PWD_REGEX = /^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%]).{8,24}$/;

adding multiple values to a field:
const CourseEnroll = mongoose.model('CourseEnroll', CourseEnrollSchema);

// Find the existing CourseEnroll document for the user
let courseEnroll = await CourseEnroll.findOne({ userId: userIdToAdd });

if (courseEnroll) {
  // User already has a CourseEnroll document, so add the new course
  courseEnroll.enrolledCourses.push(newCourseId);
  await courseEnroll.save();
} else {
  // Create a new CourseEnroll document for the user
  courseEnroll = await CourseEnroll.create({
    userId: userIdToAdd,
    enrolledCourses: [newCourseId]
  });
}


testing if regex matches
 const result = USER_REGEX.test(user)

using axios//
-first you install axios.
-create a folder called api
-create a file in the api folder called "axios.js"
then in the axios file input this code:
- import axios from "axios";

export default axios.create({
    baseURL: 'http://localhost:3500' // your api in your backend
})


import axios from "./api/axios"; // to bring the axios from the other file

// now to send response to the server 
// const REGISTER_URL = '/register'


  try {
      const response = await axios.post(REGISTER_URL, JSON.stringify({user, pwd}),
    {
      headers: {'Content-Type': 'application/json'},
      withCredentials: true
    })
    console.log(response.data)
    console.log(response.accessToken)
    console.log(JSON.stringify(response))
    setSuccess(true)
    //clear input field

    } catch (err) {
        if(!err?.response){
          setErrMsg('NO SERVER RESPONSE')
        } else if (err.response?.status){
            setErrMsg('Username Taken')
        } else {
          setErrMsg('Registration Failed')
        }
        errRef.current.focus()
    }

for the cors workings//

an allowed list of sites:

const allowedOrigins = [
    'https://www.yoursite.com',
    'http://127.0.0.1:5500',
    'http://localhost:3500',
    'http://localhost:5173'


]
module.exports = allowedOrigins

then the options

const credentials = require('../middleware/credentials')
const allowedOrigins = require('./allowedOrigins')

const corsOptions = {
    origin: (origin, callback) =>{
        if (allowedOrigins.indexOf(origin) != -1 || !origin){
            callback(null, true)

        }else{
            callback(new Error('Not allowed by CORS'))
        }
    },
    credentials: true,
    optionsSuccessStatus: 200
}

module.exports = corsOptions

then in the base server you put the middleware;
app.use(cors(corsoptions))

//using authContext properly

-firstly we created a folder called context
-then we created a file in the ontext folder called AuthProvider(it can be anything relating to your global variable)
-then we inputed the code to help decclare the global variables that we would be putting through out the components:
import { createContext, useState } from "react";


const AuthContext = createContext({});

export const AuthProvider = ({ children }) => {

    //the global variables
  const [auth, setAuth] = useState();

  return (
    <AuthContext.Provider value={{ auth, setAuth }}>
      {children}
    </AuthContext.Provider>
  );
};


export default AuthContext



-//then after that we went to the main jsx file to wrap the whole app in the contextprovider:
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import "./index.css";
import { AuthProvider } from "./context/AuthProvider.jsx";
ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <AuthProvider>
      <App />
    </AuthProvider>
  </React.StrictMode>
);

then we went to the file we needed the global variable;
firstly we imported useContext from react
- import { useRef, useState, useEffect, useContext } from "react";

-then we imported the authContext 
import AuthContext from "./context/AuthProvider";
then we imported the setAuth function from the context provider

const {setAuth} = useContext(AuthContext)


we wanted to make the using the global state easier so we creted a cutom hook
import { useContext } from "react";

import AuthContext from "../context/AuthProvider";

const useAuth = () =>{
    return useContext(AuthContext)
}

export default useAuth

 let isMounted = true
    const controller = new AbortController()

// for handling get methods when stuff has unmounted
we used an abortController accepted by axios:

  useEffect(() => {
    let isMounted = true;
    const controller = new AbortController();

    const getUsers = async () => {
      try {
        const response = await axios.get("/users", {
          signal: controller.signal,
        });
        console.log(response?.data);
        isMounted && setUsers(response.data);
      } catch (err) {
        console.log(err);
      }
    };

    getUsers();

    return () => {
      isMounted = false;
      controller.abort();
    };
  }, []);


use refresh token hook:
import axios from "../api/axios";
import useAuth from "./useAuth";

const useRefreshToken = () => {
const {setAuth} = useAuth()

const refresh = async () =>{
    const response = await axios.get('/refresh', {
        withCredentials: true
    })
    setAuth(prev => {
        console.log(JSON.stringify(prev))
        console.log(response?.data?.accessToken)
        return{...prev, accessToken: response.data.accessToken}
    })

    return response.data.accessToken
}

    return refresh
}
 
export default useRefreshToken;

the standard interceptor custom hook for when your token has expired and you want to send a token to the server:

import { axiosPrivate } from "../api/axios";
import { useEffect } from "react";
import useRefreshToken from "./useRefreshToken";
import useAuth from "./useAuth";


const useAxiosPrivate = () =>{
    const refresh = useRefreshToken()
    const {auth} = useAuth()

useEffect(() => {

    const requestIntercept = axiosPrivate.interceptors.request.use(
        config =>{
            if(!config.headers['Authorization']) {
                config.headers['Authorization'] = `Bearer ${auth?.accessToken}`
            }
            return config

        }, (error) => Promise.reject(error)
    )


now using it to perform a request:
import { useState, useEffect } from "react";
import useAxiosPrivate from "../hooks/useAxiosPrivate";
import { useNavigate, useLocation } from "react-router-dom";

const Users = () => {
    const [users, setUsers] = useState();
    const axiosPrivate = useAxiosPrivate();
    const navigate = useNavigate();
    const location = useLocation();

    useEffect(() => {
        let isMounted = true;
        const controller = new AbortController();

        const getUsers = async () => {
            try {
                const response = await axiosPrivate.get('/users', {
                    signal: controller.signal
                });
                console.log(response.data);
                isMounted && setUsers(response.data);
            } catch (err) {
                console.error(err);
                if (err?.response?.status === 403) navigate('/login', { state: {from: location }, replace: true });
                
            }
        }

        getUsers();

        return () => {
            isMounted = false;
            controller.abort();
        }
    }, [])

    return (
        <article>
            <h2>Users List</h2>
            {users?.length
                ? (
                    <ul>
                        {users.map((user, i) => <li key={i}>{user?.username}</li>)}
                    </ul>
                ) : <p>No users to display</p>
            }
        </article>
    );
};

export default Users;

using multer 
on the front end 
 const [title, setTitle] = useState("");
  const [file, setFile] = useState("");

  const submitImage = async (e) =>{
    e.preventDefault()
    const formData = new FormData()
    formData.append("title", title);
    formData.append("file", file);
    console.log(title, file);
  }

   <form className="formStyle" onSubmit={submitImage}>
        <h4>Uplpad Pdf in React</h4>
        <br />
        <input
          type="text"
          className="form-control"
          placeholder="Title"
          required
          onChange={(e) => setTitle(e.target.value)}
        />
        <br />
        <input
          type="file"
          className="form-control"
          accept="application/pdf"
          required
          onChange={(e) => setFile(e.target.files[0])}
        />
        <br />
        <br />
        <button class="btn btn-primary" type="submit">
          Submit
        </button>
      </form>

then in the backend you first install multer 
npm i multer 

then:
const multer  = require('multer')
const upload = multer({ dest: './files' })

or this


const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, './files')
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() 
    cb(null,  uniqueSuffix+file.originalname)
  }
})

const upload = multer({ storage: storage })

app.post('/upload-files', upload.single("file"), async  (req, res) =>{ //the file is referring to the key and value file p from the formData() object
  console.log(req.file)
const title = req.body.title
const filename = req.file.filename
try{
await pdfSchema = await pdfDetails.create({title, pdf: filename})

})


now on the front end to upload files
do the normal axios
axios.js:
import 'axios' from 'axios'
BASE_URL: '/YOUR-API'

export deafult const axios.create({
  baseURL: BASE_URL, })

then in the file function
try{
      const response = await axios.post(FILE_ROUTE, formData, {
        headers: {"Content-Type": "multipart/form-data"}
    } )
    console.log(response.data)
    }catch(err){
      console.log(err.message)
    }
  }






const courseId = "your_course_id_here"; // Replace with the actual courseId you want to check

async function getEnrolledUserIds(courseId) {
  try {
    const result = await CourseEnrollSchema.find(
      { enrolledCourses: { $in: [courseId] } },
      { userId: 1, _id: 0 }
    )
    .populate("userId", "name email");

    const users = result.map((doc) => doc.userId);
    return users;
  } catch (error) {
    console.error(error);
    throw error;
  }
}

getEnrolledUserIds(courseId)
  .then((users) => {
    console.log(users);
  })
  .catch((error) => {
    console.error(error);
  });

this is done in the root location of the fullstack app,
"scripts": {
    "backend": "nodemon server/index.js",
    "frontend": "npm run dev --prefix client",
    "dev": "concurrently \"npm run client\" \"npm run server\""
  }

//error 
Status code	Meaning
1xx Informational	 
100	Continue
101	Switching protocols
102	Processing
103	Early Hints
 	 
2xx Succesful	 
200	OK
201	Created
202	Accepted
203 	Non-Authoritative Information
204	No Content
205	Reset Content
206	Partial Content
207	Multi-Status
208	Already Reported
226	IM Used
 	 
3xx Redirection	 
300	Multiple Choices
301	Moved Permanently
302	Found (Previously "Moved Temporarily")
303	See Other
304	Not Modified
305	Use Proxy
306	Switch Proxy
307	Temporary Redirect
308	Permanent Redirect
 	 
4xx Client Error	 
400	Bad Request
401	Unauthorized
402	Payment Required
403	Forbidden
404	Not Found
405	Method Not Allowed
406	Not Acceptable
407	Proxy Authentication Required
408	Request Timeout
409	Conflict
410	Gone
411	Length Required
412	Precondition Failed
413	Payload Too Large
414	URI Too Long
415	Unsupported Media Type
416	Range Not Satisfiable
417	Expectation Failed
418	I'm a Teapot
421	Misdirected Request
422	Unprocessable Entity
423	Locked
424	Failed Dependency
425	Too Early
426	Upgrade Required
428	Precondition Required
429	Too Many Requests
431	Request Header Fields Too Large
451	Unavailable For Legal Reasons
 	 
5xx Server Error	 
500	Internal Server Error
501	Not Implemented
502	Bad Gateway
503	Service Unavailable
504	Gateway Timeout
505	HTTP Version Not Supported
506	Variant Also Negotiates
507	Insufficient Storage
508	Loop Detected
510	Not Extended
511	Network Authentication Required

// using bcrypt: don't know why i didn't do this sooner 
  const salt = await bcrypt.genSalt(10);
  const hashedPassword = await bcrypt.hash(password, salt);

//creating token function: we put it in a util folder and called it after we created a new user
const jwt = require('jsonwebtoken')
const path = require('path')
require('dotenv').config({ path: path.join(__dirname, '../.env') });





const generateToken = (res, userId) =>{
    const token = jwt.sign({userId}, process.env.JWT_SECRET,{
        expiresIn: '30d'
    })
    //set JWT as HTTP-only cookie
    res.cookie('jwt', token, {
        httpOnly: true,
        secure: process.env.NODE_ENV != 'development',
        sameSite: "strict",
        maxAge: 30 * 24 * 60 * 60 * 1000 
    })

    return token
}

module.exports = generateToken 

//logging out user:
const logoutCurrentUser = async(req, res) =>{
    res.cookie('jwt', '',{
        httpOnly: true,
        expires: new Date(0)
    } )
        res.status(200).json({message: "Logged Out Successfully"})
}

      

//authenticating a user
const authenticate = async (req, res, next) => {
  let token;

  // Read JWT from the 'jwt' cookie
  token = req.cookies.jwt;

  if (token) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = await User.findById(decoded.userId).select("-password");
      next();
    } catch (err) {
      res.status(401).json({ message: "Not Authorised, token failed" });
    }
  } else {
    res.status(401).json({ message: "Not Authorised, token failed" });
  }
};

//new method of deleting:
const deleteUser = async (req, res) => {
  const { id } = req.params;
  try {
    const user = await User.findById(id);
    if (!user) return res.status(404).json({ message: "user not found" });

    if (user) {
      if (user.isAdmin) {
        res.status(400).json({ message: "Cannot delete Admin" });
      }

      await User.deleteOne({ _id: user._id });
      res.json({ message: `${user.username} deleted successfully` });
    }
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// admin part
  user.isAdmin = Boolean(req.body.isAdmin)


//the new routing method
import AuthContextProvider from "./context/AuthContext";

App.jsx

import { Outlet } from "react-router-dom";
import Navigation from "./components/Navigation";
import { ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import AuthContextProvider from "./context/AuthContext";

function App() {
  return (
    <>
      <ToastContainer />
      <Navigation />
      <main className="py-3">
        <Outlet />
      </main>
    </>
  );
}

function Root() {
  return (
    <AuthContextProvider>
      <App />
    </AuthContextProvider>
  );
}

function Root() {
  return (
    <AuthContextProvider>
  <App />
    </AuthContextProvider>
  );
}

export default Root;

main.jsx
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import Root from "./App.jsx";
import { RouterProvider, createBrowserRouter } from "react-router-dom";
import Login from "./pages/Login.jsx";
import Test from "./pages/Test.jsx";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    children: [
      { path: "login", element: <Login /> },
      { path: "test", element: <Test /> },

    ],
  },
]);

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);

automatic redirection
const navigate = useNavigate()
const {search} = useLocation()
const sp = new URLSearchParams(search)
const redirect = sp.get('redirect') || '/'


useEffect(() => {
    if (userInfo) {
        navigate(redirect)
    }
}, [navigate, redirect]);


persistentMap saves the entire entity as sepetate entitites in the local storage


proper use of persistentAtom:
import { persistentAtom } from '@nanostores/persistent';

// Persistent object for user info
export const userStore = persistentAtom('userInfo', {}, {
  encode: JSON.stringify,
  decode: JSON.parse,
});

// Persistent array for items
export const itemsStore = persistentAtom('items', [], {
  encode: JSON.stringify,
  decode: JSON.parse,
});

// Persistent single value for a boolean
export const isDarkMode = persistentAtom('darkMode', false, {
  encode: String,
  decode: (value) => value === 'true',
});

import { useStore } from '@nanostores/react';
import { userStore, itemsStore, isDarkMode } from '../stores/userStores';

const MyComponent = () => {
  const userInfo = useStore(userStore);
  const items = useStore(itemsStore);
  const darkMode = useStore(isDarkMode);

  const toggleDarkMode = () => isDarkMode.set(!darkMode);
  const addItem = (item) => itemsStore.set([...items, item]);

  return (
    <div>
      <p>User: {userInfo.username}</p>
      <button onClick={toggleDarkMode}>
        {darkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'}
      </button>
      <ul>
        {items.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
      <button onClick={() => addItem('New Item')}>Add Item</button>
    </div>
  );
};

export default MyComponent;

//editing array;
 const editArray = (updatedUsername, updatedEmail, id) =>{

    const updatedUsers = users.map(user => 
        user._id === id 
          ? { ...user, username: updatedUsername, email: updatedEmail } 
          : user
      );
      
 
fetcing all products using keywords and pagination:
const fetchProducts = async (req, res) => {
  try {
    const pageSize = 6;
    const keyword = req.query.keyword
      ? { name: { $regex: req.query.keyword, $options: "i" } }
      : {};

    const count = await Product.countDocuments({ ...keyword });
    const products = await Product.find({ ...keyword }).limit(pageSize);

    res.json({
      products,
      page: 1,
      pages: Math.ceil(count / pageSize),
      hasMore: false,
    });
  } catch (err) {
    res.status(500).json({message: err.message})
  }
};

adding reviews:
const addProductReview = async (req, res) =>{
try {
  const {rating, comment} = req.body
  const product = await Product.findById(req.params.id)

  if(product){
    const alreadyReviewed = product.reviews.find(r => r.user.toString() === req.user._id.toString())

    if(alreadyReviewed) {
      res.status(400).json({message: "Product already reviewed"})
}
  const review ={
    name: req.user.username,
    rating: Number(rating),
    comment,
    user:req.user._id
  }
  product.reviews.push(review)
  product.numReviews = product.reviews.length

  let totalRating = 0

  product.reviews.forEach((review) => {
    totalRating += review.rating;
  });
  
  product.rating = totalRating / product.reviews.length;
  
  await product.save()
  res.status(201).json({message: "Review Added"})

  }else{
    res.status(404).json({message: "Product not found"})
  }
  
} catch (error) {
  res.status(500).json({messae: error.message})
}
}

1. ISO 8601 Format (Recommended)
The ISO 8601 format is:

json
Copy code
YYYY-MM-DDTHH:mm:ss.sssZ
Example:
For November 25, 2024, at 10:00 AM UTC:

json
Copy code
2024-11-25T10:00:00.000Z
Postman Input:
If your API expects a date field, provide it in the body like this:

json
Copy code
{
    "startTime": "2024-11-25T10:00:00.000Z"
}


const leaveSession = async (req, res) => {
  try {
    const { sessionid } = req.params;
    const userid = req.user._id;

    // Find the session and remove the user from members
    const session = await Session.findByIdAndUpdate(
      sessionid,
      { 
        $pull: { members: userid }, // Remove the specific user ID from members
        $set: { isFull: false } // Reset isFull if it was true
      },
      { new: true } // Return the updated document
    );

    if (!session) {
      return res.status(404).json({ message: "Session not found" });
    }

    // Update the user's current session and return the updated user
    const updatedUser = await User.findByIdAndUpdate(
      userid, 
      { currentSession: null },
      { new: true } // Return the updated user document
    );

    res.status(200).json({ session, user: updatedUser });
  } catch (err) {
    console.error("Error in leaveSession:", err);
    res.status(500).json({ message: err.message });
  }
};

    await Promise.all(
      members.map(async (memberId) => {
        const user = await User.findById(memberId);
        if (user) {
          user.currentSession = null;
          user.isCaptain = false;
          await user.save();
        }
      })
    );


const createAndAllocateSet = async (req, res) => {
  try {
    const { sessionid } = req.params;

    const setName = [
      "Team 7", "Royal Knights", "Bouillon Fc", "Sepulcher FC", "Akatsuki", "Amapiano FC", 
      "Grey Fc", "Dynasty", "Elon Musk Fc", "J-boys FC", "Sporty9ja", "Wizkidfc", "30BG", 
      "Valdomites", "OV-Hoes", "Outsiders", "Celeboys", "Azonto FC", "Akara warriors", "Egusi FC"
    ];

    // Fetch session
    const session = await Session.findById(sessionid);
    const { setNumber } = session;
    console.log(`Creating ${setNumber} teams for session: ${sessionid}`);

    // Fetch existing sets for this session to track used names
    const existingSets = await Set.find({ session: session._id });

    // Get the names already used in this session
    const usedNames = existingSets.map(set => set.name);

    // Initialize available names list, excluding used names
    const availableNames = setName.filter(name => !usedNames.includes(name));

    // Check if there are enough unique names available
    if (availableNames.length < setNumber) {
      return res.status(400).json({ message: "Not enough unique names available for the session" });
    }

    const setData = [];

    // Generate sets with unique names for the session
    for (let i = 1; i <= setNumber; i++) {
      // Select a random name from the available names
      const randomIndex = Math.floor(Math.random() * availableNames.length);
      const randomName = availableNames.splice(randomIndex, 1)[0]; // Remove the selected name

      setData.push({
        session: session._id,
        name: randomName,
        players: []
      });
    }

    // Insert the sets into the database
    const createdSets = await Set.insertMany(setData);

    res.status(201).json(createdSets);
  } catch (err) {
    res.status(500).json({ message: "Internal server error" });
    console.log(err);
  }
};



flatMap() => reduces an array to one level

const allocateMembers = async (session, createdSets) => {
  const members = session.members;

  const pickedMembers = createdSets.players.flatMap((player) => player);

  const availablePlayers = members.filter(
    (member) => !pickedMembers.includes(member)
  );


  for (i = 0; i < members.length; i++) {
    const player = availablePlayers.shift();

    const setIndex =  i % createdSets.length;
    const pickedSet = createdSets[setIndex];

    pickedSet.players.push(player);
    await pickedSet.save()
  }
};

const createSet = async (req, res) => {
  try {
    const { sessionid } = req.params;

    const setName = [
      "Team 7",
      "Royal Knights",
      "Bouillon Fc",
      "Sepulcher FC",
      "Akatsuki",
      "Amapiano FC",
      "Grey Fc",
      "Dynasty",
      "Elon Musk Fc",
      "J-boys FC",
      "Sporty9ja",
      "Wizkidfc",
      "30BG",
      "Valdomites",
      "OV-Hoes",
      "Outsiders",
      "Celeboys",
      "Azonto FC",
      "Akara warriors",
      "Egusi FC",
    ];

    const session = await Session.findById(sessionid);
    const { setNumber } = session;


    if (!session) return res.status(409).json({ message: "Session not found" });

    const existingSets = await Set.find({ session: sessionid });

    const usedNames = existingSets.map((set) => set.name);

    const availableNames = setName.filter((name) => !usedNames.includes(name));

    // Check if there are enough unique names available
    if (availableNames.length < setNumber) {
      return res
        .status(400)
        .json({ message: "Not enough unique names available for the session" });
    }

    const setData = [];

    for (i = 0; i < setNumber; i++) {
      const randomIndex = Math.floor(Math.random() * availableNames.length);
      const randomName = availableNames[randomIndex];

      setData.push({
        session: session._id,
        name: randomName,
        players: [],
      });

      availableNames.splice(randomIndex, 1);
    }

    const createdSets = await Set.insertMany(setData);

    await allocateMembers(session, createdSets)

    res.status(201).json({ messae: "sets created Sucessfully" }, createdSets);
  } catch (err) {
    res.status(500).json({ message: "Internal server error" });
    console.log(err);
  }
};

//proper way of connecting DB

const mongoose = require("mongoose");
require("dotenv").config();

const connDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
  } catch (err) {
    console.log(err);
  }
};

module.exports = connDB;


//server file

connDB()

mongoose.connection.once("open", () => {
  app.listen(PORT, () => {
    console.log(`server running on port ${PORT} and connected to database`);
  });
});


//mongoDB query operators
$eq: Matches values that are equal to a specified value.
$gt: Matches values that are greater than a specified value.
$gte: Matches values that are greater than or equal to a specified value.
$lt: Matches values that are less than a specified value.
$lte: Matches values that are less than or equal to a specified value.
$ne: Matches values that are not equal to a specified value.
$in: Matches any of the values specified in an array.
$nin: Matches none of the values specified in an array.

  for (let i = 0; i < members.length; i++) {
    const player = availablePlayers[i];

    const setIndex = i % createdSets.length;
    const pickedSet = createdSets[setIndex];

    pickedSet.players.push(player);
    await pickedSet.save();
  }

   while (availablesets.length > 0) {
      const randomIndex1 = Math.floor(Math.random() * availablesets.length);
      const randomTeam1 = availablesets[randomIndex1];
      availablesets.splice(randomIndex1, 1);

      const randomIndex2 = Math.floor(Math.random() * availablesets.length);
      const randomTeam2 = availablesets[randomIndex2];
      availablesets.splice(randomIndex2, 1);


      matchUp.push({
        teamOne: randomTeam1,
        teamTwo: randomTeam2,
        session: sessionid,
      });
    }

import React from "react";

import Header from "../components/Header/Header";
import Footer from "../components/Footer/Footer";
import Routers from "../routers/Routers";

const Layout = () => {
  return (
    <>
      <Header />
      <main>
        <Routers />
      </main>
      <Footer />
    </>
  );
};

export default Layout;

import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App.jsx";
import { BrowserRouter } from "react-router-dom";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </StrictMode>
);


git fetch upstream
git checkout main  # Ensure you're on main
git merge upstream/main
git checkout <your-branch>
git merge upstream/main
git add .
git commit -m "Resolved merge conflicts"
git push origin main


app.post('/webhook', (req, res) => {
    const payload = req.body;
    if (payload.event === 'charge.completed' && payload.data.status === 'successful') {
        // Extract the necessary data
        const { customer, amount, currency, transaction_id } = payload.data;

        // Generate PDF and Send Email
        generateAndSendPDF(customer.email, amount, currency, transaction_id);
    }
    res.sendStatus(200);
});


npm install pdf-lib

const { PDFDocument, rgb } = require('pdf-lib');
const fs = require('fs');

async function generatePDF(customerEmail, amount, currency, transactionId) {
    const pdfDoc = await PDFDocument.create();
    const page = pdfDoc.addPage([600, 400]);
    const { width, height } = page.getSize();

    page.drawText('Payment Receipt', { x: 200, y: 350, size: 24, color: rgb(0, 0.53, 0.71) });
    page.drawText(`Customer: ${customerEmail}`, { x: 50, y: 300, size: 14 });
    page.drawText(`Amount Paid: ${amount} ${currency}`, { x: 50, y: 270, size: 14 });
    page.drawText(`Transaction ID: ${transactionId}`, { x: 50, y: 240, size: 14 });
    page.drawText('Thank you for your payment!', { x: 50, y: 210, size: 14 });

    const pdfBytes = await pdfDoc.save();
    fs.writeFileSync('receipt.pdf', pdfBytes);

    return pdfBytes; // Return the generated PDF bytes for emailing
}


npm install nodemailer

const nodemailer = require('nodemailer');

async function sendEmailWithPDF(email, pdfBytes) {
    const transporter = nodemailer.createTransport({
        service: 'Gmail',
        auth: {
            user: 'your-email@gmail.com',
            pass: 'your-password'
        }
    });

    const mailOptions = {
        from: 'your-email@gmail.com',
        to: email,
        subject: 'Your Payment Receipt',
        text: 'Attached is your payment receipt.',
        attachments: [
            {
                filename: 'receipt.pdf',
                content: pdfBytes,
                contentType: 'application/pdf'
            }
        ]
    };

    await transporter.sendMail(mailOptions);
    console.log('Email sent successfully');
}

async function generateAndSendPDF(email, amount, currency, transactionId) {
    try {
        const pdfBytes = await generatePDF(email, amount, currency, transactionId);
        await sendEmailWithPDF(email, pdfBytes);
    } catch (err) {
        console.error('Error generating or sending PDF:', err);
    }
}

//typescript section 

npm i express @types/express
npm i nodemon
npm i mongoose
npm i @types/mongoose
npm i typescript ts-node

 "scripts": {
    "start": "nodemon"
  },

//tsconfig.json file
{
    "compilerOptions": {
        "target": "ES6",
        "module": "NodeNext",
        "moduleResolution": "NodeNext",
        "lib": ["ES6"],
        "sourceMap": true,
        "strict": true,
        "noImplicitAny": true,
        "esModuleInterop": true,
        "resolveJsonModule": true,
        "allowJs": true,
        "rootDir": "src",
        "baseUrl": "./",
        "outDir": "dist",
        "paths": {
            "@handlers/*": ["src/handlers/*"],
            "@models/*": ["src/models/*"],
            "@repositories/*": ["src/repositories/*"],
            "@usecases/*": ["src/usecases/*"],
            "@routes/*": ["src/routes/*"],
            "@config/*": ["src/config/*"],
            "@middlewares/*": ["src/middlewares"],
            "@validation/*": ["src/validation"]


        }
    },
    "include": ["src/**/*"]
}	


//nodemon.json (should be in the root folder)
{
    "watch": [
        "src"
    ],
    "ext": ".ts,.js",
    "exec": "ts-node ./src/index.ts"
}




//learning swagger
npm i swagger-ui-express yamljs

//format for swagger.yaml
openapi: 3.0.0
info: 
  title: Sample API
  description: API documentation Example
  version: 1.0.0
paths: 
  /:
    get:
      summary: Returns a greeting
      responses:
        200:
          description: greeting response
          content:
            application/json:
              schema: 
                type: string
                example: Hello World


//server look:
import express from "express";
import swaggerUi from "swagger-ui-express";
import YAML from "yamljs";
const swaggerDocument = YAML.load("./swagger.yaml");
import { Request, Response } from "express";
const app = express();
const port = 3000;
app.use(express.json());

app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerDocument));

app.get("/", (req: Request, res: Response) => {
  res.send("Hello World");
});

app.listen(port, () => {
  console.log("server runnning");
});


//express-js-doc-swagger
npm i express-jsdoc-swaggers

const options = {
    info: {
        version: "1.0.0",
        title: "items API",
        desscription: "A Simple API to manage list of items"
    },
    baseDir: __dirname,
    filesPattern: "./*.ts"
}

expressJSDocSwagger(app)(options)

//standard documentation for get
/**
 * GET /
 * @summary Get all items
 * @description Returns list of all items
 * @response 200 - A list of items - application/json
 * @responseBody {User[]}
 */

      // "^.+\\.(js|jsx)$": "babel-jest"  



//testing p
import request from 'supertest';
import middleware from '../../middleware/index';
import { authService } from '../../services/authService';
import { userUsecase } from '../../usecases/userUsecase';
import { notificationService } from '../../services/notificationService';
import { responseManager } from '../../utils/responseManager';

// Mock dependencies to prevent database interaction
jest.mock('../../services/authService');
jest.mock('../../usecases/userUsecase');
jest.mock('../../services/notificationService');
jest.mock('../../utils/responseManager');

describe("Authentication - Login", () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    it("should return error if email is missing", async () => {
        const response = await request(middleware.getApp())
            .post('/auth/login')
            .send({ otp: "123456" });

        expect(response.status).toBe(400);
        expect(response.body.message).toBe("Missing required fields: email");
    });

    it("should return error if email format is invalid", async () => {
        const response = await request(middleware.getApp())
            .post('/auth/login')
            .send({ email: "invalid-email", otp: "123456" });

        expect(response.status).toBe(400);
        expect(response.body.message).toBe("Invalid email address");
    });

    it("should send OTP if OTP is not provided", async () => {
        (authService.validateOTPOnAccess as jest.Mock).mockResolvedValue({ success: true });

        const response = await request(middleware.getApp())
            .post('/auth/login')
            .send({ email: "test@example.com" });

        expect(authService.validateOTPOnAccess).toHaveBeenCalledWith({
            type: "EMAIL",
            email: "test@example.com",
        });

        expect(response.status).toBe(200);
        expect(response.body.message).toBe("OTP sent");
    });

    it("should return error if OTP is incorrect", async () => {
        (authService.loginUser as jest.Mock).mockRejectedValue(new Error("Invalid OTP"));

        const response = await request(middleware.getApp())
            .post('/auth/login')
            .send({ email: "test@example.com", otp: "wrongOTP" });

        expect(response.status).toBe(400);
        expect(response.body.message).toBe("Invalid OTP");
    });

    it("should login successfully with correct OTP", async () => {
        (authService.loginUser as jest.Mock).mockResolvedValue({
            userId: "12345",
            token: "mocked-jwt-token",
        });

        (responseManager.success as jest.Mock).mockImplementation((res, data, message) => {
            res.status(200).json({ success: true, message, data });
        });

        const response = await request(middleware.getApp())
            .post('/auth/login')
            .send({ email: "test@example.com", otp: "123456" });

        expect(authService.loginUser).toHaveBeenCalledWith({
            otp: "123456",
            email: "test@example.com",
            ip: expect.any(String),
        });

        expect(response.status).toBe(200);
        expect(response.body.message).toBe("Login successful");
        expect(response.body.data.token).toBe("mocked-jwt-token");
    });

    it("should return 2FA required if the user has 2FA enabled", async () => {
        (authService.loginUser as jest.Mock).mockResolvedValue({
            userId: "12345",
            partialToken: "mocked-partial-token",
            twoFA: true,
        });

        const response = await request(middleware.getApp())
            .post('/auth/login')
            .send({ email: "2fauser@example.com", otp: "123456" });

        expect(response.status).toBe(200);
        expect(response.body.message).toBe("2FA Required");
        expect(response.body.data.partialToken).toBe("mocked-partial-token");
    });

    it("should return an error if database operation fails", async () => {
        (authService.loginUser as jest.Mock).mockRejectedValue(new Error("Database operation failed"));

        const response = await request(middleware.getApp())
            .post('/auth/login')
            .send({ email: "error@example.com", otp: "123456" });

        expect(response.status).toBe(500);
        expect(response.body.message).toBe("Database operation failed");
    });
});


//nest begginings

install globally 
npm i -g @nestjs/cli

start new project
nest new projectname

creating modules
nest generate module module-name

creating controllers for modules
nest generate controller module-name

adding validation pipes
npm install class-validator class-transformer

  app.useGlobalPipes(new ValidationPipe({whitelist: true, forbidNonWhitelisted: true}))
	 create(@Body(ValidationPipe) input: CreateEpisodeDto)


//generating guards
nest generate guard <path>/<name>

using mongose with nestjs
npm i @nestjs/mongoose mongoose

//registering mongoose for the app in the app module:
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { UsersModule } from './users/users.module';

@Module({
  imports: [
    MongooseModule.forRoot('mongodb://localhost:27017/nest'),
    UsersModule
  ],
  controllers: [],
  providers: [],
})
export class AppModule {}


schema creation
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import mongoose from 'mongoose';
import { UserSettings } from './UserSettings.schema';

@Schema()
export class User {
  @Prop({ unique: true, required: true })
  username: string;

  @Prop({ required: false })
  displayName?: string;

  @Prop({ required: false })
  avatarUrl?: string;

  @Prop({ type: mongoose.Schema.Types.ObjectId, ref: () => UserSettings })
  setting?: UserSettings;
}

const UserSchema = SchemaFactory.createForClass(User);

export default UserSchema;

//then registering the schema for that module:

import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import UserSchema, { User } from 'src/Schemas/User.schema';

@Module({
    imports: [
        MongooseModule.forFeature([
            {
                name: User.name,
                schema: UserSchema
            }
        ])
    ]
})
export class UsersModule {}

In NestJS, you only need a constructor when:

You want to inject dependencies (like other services, repositories, configs, etc.).

You need to initialize something with parameters at class creation time.

//injecting models into your service: 
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User } from 'src/Schemas/User.schema';

@Injectable()
export class UsersService { 

constructor(@InjectModel(User.name) private userModel: Model<User>){}

}

@validateNested() decorator-to validate referenced fields


$regex is a MongoDB operator that allows you to search strings using patterns, just like a search filter.

searching request  using pagination:
  findAll = async (query: Query): Promise<Array<Book>> => {
    const resPerPage = 2;
    const currentPage = Number(query.page) || 1;
    const skip = resPerPage * (currentPage - 1);

    const keyword = query.keyword
      ? {
          title: {
            $regex: query.keyword,
            $options: 'i',
          },
        }
      : {};
    const books = await this.bookModel
      .find({ ...keyword })
      .limit(resPerPage)
      .skip(skip);
    return books;
  };

//passport installation
npm install --save @nestjs/passport passport passport-local
 npm install --save-dev @types/passport-local

npm install @nestjs/passport passport passport-jwt
npm install --save-dev @types/passport-jwt



//auth in nest js
import { Module } from '@nestjs/common';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import mongoose from 'mongoose';
import { MongooseModule } from '@nestjs/mongoose';
import UserSchema, { User } from './schemas/user.schema';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { config } from 'process';
import { JwtStrategy } from './jwt.strategy';

@Module({
  imports: [

    PassportModule.register({defaultStrategy: 'jwt'}),
    JwtModule.registerAsync({
      inject: [ConfigService],
      useFactory: (config: ConfigService) =>{
        return{
          secret: config.get<string>('JWT_SECRET'),
          signOptions: {
            expiresIn: config.get<string | number>('JWT_EXPIRES')
          }
        }
      }
    }),
    MongooseModule.forFeature([
      {
        name: User.name,
        schema: UserSchema,
      },
    ]),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
  exports:[JwtStrategy, PassportModule ]
})
export class AuthModule {}


//passport strategy
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { User } from './schemas/user.schema';
import { Model } from 'mongoose';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    @InjectModel(User.name)
    private userModel: Model<User>,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: process.env.JWT_SECRET!,
    });
  }

  async validate(payload) {
    const { id } = payload;

    const user = await this.userModel.findById(id);

    if (!user) throw new UnauthorizedException('Login first to access this');

    return user;
  }
}


import { SetMetadata } from "@nestjs/common"
import { Role } from "src/config/constants.config"

export const ROLES_KEY = 'roles'
export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles)

import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';
import { Role } from 'src/config/constants.config';
import { ROLES_KEY } from '../decorators/roles.decorator';

export enum Roles{
User = "user",
Admin = "admin",
Moderator = "moderator"
}

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
        context.getHandler(),
        context.getClass()
    ] )


    if(!requiredRoles) return true

    const request = context.switchToHttp().getRequest()

    const user = request.user

    return matchRoles(requiredRoles, user?.role)
  }
}


const matchRoles = (requiredRoles: string[], userRole: string) =>{
        return requiredRoles.some((role: string) => userRole?.includes(role))
}


@Get()
  @Roles(Role.Moderator, Role.Admin, Role.User)
  @UseGuards(AuthGuard(), RolesGuard)
  async findAll(@Query() query: ExpressQuery): Promise<Array<Book>> {
    const books = await this.bookService.findAll(query);
    return books;
  }

constructor(private reflector: Reflector): Reflector is a helper from NestJS used to read metadata set by decorators (like your @Roles() decorator).

zap-blog-v2-git-push

ATBBD7Pcdtpjs2ePxRDvqGnC6VpJFFD894B3


import swaggerJSDoc from "swagger-jsdoc";
import swaggerUi from "swagger-ui-express";
import path from "path";
import { Application } from "express";

//new function to set up the swagger configuration
const setUpSwagger = (app: Application) => {
  const options = {
    definition: {
      openapi: "3.0.0",
      info: {
        title: "ZAP v2 API Documentation",
        version: "1.0.0",
        description: "API documentation",
      },
      servers: [
        { url: "http://localhost:3005" },
        { url: "https://test-backend-2.zap.africa"},
      ],
      components: {
        securitySchemes: {
          BearerAuth: {
            type: "http",
            scheme: "bearer",
            bearerFormat: "JWT",
          },
        },
      },
    },
    apis: [
      path.join(__dirname, "../**/*.js"), // For compiled JS files
      path.join(__dirname, "../**/*.ts"), // For TS files in development
      path.join(__dirname, "../routes/**/*.js"), // Common route locations
      path.join(__dirname, "../routes/**/*.ts"),
      path.join(__dirname, "../controllers/**/*.js"), // Controller files may have route definitions
      path.join(__dirname, "../controllers/**/*.ts"),
      path.join(__dirname, "../deliverymen/**/*.js"), // Your specific directory
      path.join(__dirname, "../deliverymen/**/*.ts"),
     
    ],
  };

  const specs: swaggerJSDoc.Options = swaggerJSDoc(options);
  if (!specs) {
    console.error("Failed to generate Swagger specs");
    return;
  }

  console.log(
    "Generated Swagger paths:",
    Object.keys((specs as any).paths || {}).length
  );
  console.log(
    "API paths found:",
    specs.paths ? Object.keys(specs.paths) : "None"
  );

  app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(specs));
  console.log("Swagger UI set up at /api-docs");
};

export default setUpSwagger;

// killing ports
netstat -ano | findstr :3005
taskkill /PID 12345 /F




 const page = req.query.page ? parseInt(req.query.page as string) : 1;
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 10;
  
      const skip = (page - 1) * limit;
	

//logging in zap:
{
  "email": "chidiebere@zap.africa",
  "otp": "282267"

}
